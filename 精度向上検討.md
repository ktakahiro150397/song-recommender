# 楽曲レコメンド精度向上の検討

## 元の課題（Issue より）

> **Issue**: なんか精度落ちてないか？
> 
> **詳細**: 母数が増えたことで前からあったいきなり違う曲になる現象の違和感が強烈。関連なさそうな自分の知らない曲に飛ぶから脳みそが飽きてしまう。
> 
> **コメント**: なんすかね〜 コサイン距離以外の導入で解決できるのか、DeepLearningまでやるかのいずれかかな

→ **この検討文書では、「コサイン距離以外の導入」と「DeepLearning導入」の両方について、具体的な解決策と実装方法を提示します。**

---

## 問題の整理

### 現状の課題

**核心的な問題:**
1. **「いきなり違う曲になる」**: 連鎖検索中に突然、全く異なる雰囲気の曲に飛んでしまう
2. **「関連なさそうな知らない曲に飛ぶ」**: 似ているはずなのに、ユーザーが知らない（＝おそらく違うジャンル・雰囲気の）曲が推薦される
3. **「脳みそが飽きてしまう」**: 予想外の曲が続くことで、聴く意欲が失われる

**技術的な背景:**
データベースの楽曲数が増加したことで、ベクトル空間の密度が変化し、局所的な類似性の精度が低下している。現在のCosine距離のみのアプローチでは、微妙な「曲調の違い」を捉えきれていない。

### 現在の実装

#### 音声特徴量抽出
- **ライブラリ**: librosa
- **特徴量**: 
  - MFCC (20次元) + MFCC Delta (20次元): 音色・質感
  - Chroma (12次元): 和音・調性
  - Tonnetz (6次元): 和声的関係
  - Spectral特徴量 (7次元): Contrast, Centroid, Rolloff等
  - リズム・エネルギー (3次元): Tempo, RMS, Zero Crossing Rate
- **モード**:
  - minimal: 15次元（テンポ・明るさ重視）
  - balanced: 33次元（汎用的）
  - full: 72次元（全特徴量）

#### 類似度計算
- **距離関数**: Cosine距離
- **ベクトルDB**: ChromaDB (HNSW index)
- **検索方式**: 連鎖検索（各ステップで最も近い未訪問曲を選択）

---

## 問題の原因分析

### 1. 次元の呪い（Curse of Dimensionality）

**問題点:**
- 高次元空間（特にfullモードの72次元）では、すべての点が等距離に見える傾向
- Cosine距離だけでは、微妙な差異を捉えきれない
- 距離の分散が小さくなり、「似ている」と「似ていない」の境界が曖昧に

**影響:**
- 本来類似していない曲が「距離が近い」と判定される
- 連鎖検索で急に違うジャンルに飛んでしまう

### 2. 特徴量の均質化

**問題点:**
- librosaの統計量（平均値）だけでは、時系列の構造情報が失われる
- 異なる曲でも、平均化すると似たベクトルになってしまう可能性
- 特にChroma（調性）の重みが、実際の「曲調の似た感じ」と一致しない場合がある

**影響:**
- 調性は同じだが、リズムや雰囲気が全く異なる曲が類似と判定される
- 「曲調」ではなく「音響特性」の類似になっている

### 3. 連鎖検索の蓄積誤差

**問題点:**
- 連鎖検索では、各ステップでの微小な誤差が蓄積
- 最初は似ていても、10曲、20曲と進むうちに元の曲とかけ離れる
- 距離の閾値がないため、「どれだけ似ていないか」の判断ができない

**影響:**
- プレイリストの後半が元の曲と無関係になる
- ユーザーが違和感を感じる

### 4. データセットの偏り

**問題点:**
- 特定のジャンルや音源（例: アイドルマス系楽曲）が大量にある場合、ベクトル空間がそちらに偏る
- レアなジャンルの楽曲は孤立し、不適切な類似曲と結びつく可能性

---

## 質問への回答：「コサイン距離以外」vs「DeepLearning」

### 結論

**両方とも必要です。ただし、段階的に導入することを推奨します。**

1. **まず「コサイン距離以外」の手法を導入** (1〜2週間で効果確認)
   - 距離閾値、複合距離関数、重み付け最適化
   - → 即座に「いきなり違う曲」問題の軽減が見込める

2. **次に「DeepLearning」を導入** (1〜2ヶ月)
   - OpenL3などの深層学習埋め込みモデル
   - → 本質的な精度向上（10〜30%改善見込み）

3. **継続的な改善** (3ヶ月〜)
   - ユーザーフィードバックループ、より高度なモデル

### なぜこの順番か？

- **短期施策（コサイン以外）**: リスクが低く、既存システムへの影響が小さい。すぐに効果を確認できる
- **中期施策（DeepLearning）**: 本質的な解決だが、計算コストや実装難易度が高い。短期施策の効果を見てから判断できる
- **並行実装も可能**: 短期施策を実装しながら、DeepLearningモデルの検証を進めることも可能

---

## 解決策の提案

### 短期的改善（すぐ実装可能）: コサイン距離以外の導入

#### 1. **距離閾値の導入**

**内容:**
- 連鎖検索時に「最大距離」を設定
- 例: `distance > 0.01` の場合は連鎖を打ち切る、または警告を出す
- ユーザーに「ここから先は類似度が低下します」と通知

**効果:**
- **「いきなり違う曲」問題に直接効く** ← Issue の核心的な問題
- 急激な曲調変化を防ぐ
- 実装が簡単（数行の変更）

**実装難易度**: ⭐☆☆☆☆ (非常に簡単)

**実装例:**
```python
MAX_DISTANCE_THRESHOLD = 0.01  # 調整可能

if best_distance > MAX_DISTANCE_THRESHOLD:
    print(f"⚠️ 類似度が低下しています（距離: {best_distance:.6f}）")
    # オプション: 検索を打ち切る or 続ける
```

#### 2. **複合距離関数の使用** ← コサイン以外の導入

**内容:**
- Cosine距離だけでなく、L2距離や内積も併用
- 複数の距離を組み合わせたスコアを計算
  - 例: `score = 0.7 * cosine + 0.3 * l2_normalized`

**効果:**
- **異なる視点での類似性を考慮** ← Issue の「関連なさそうな曲」問題に効く
- ベクトルの「向き」と「大きさ」の両方を評価
- Cosine距離の欠点（音量・エネルギーの違いを無視）を補完

**実装難易度**: ⭐⭐☆☆☆ (簡単)

**実装例:**
```python
def combined_distance(vec1, vec2):
    cosine_dist = cosine_distance(vec1, vec2)
    l2_dist = np.linalg.norm(vec1 - vec2)
    l2_normalized = l2_dist / np.sqrt(len(vec1))  # 次元数で正規化
    return 0.7 * cosine_dist + 0.3 * l2_normalized
```

#### 3. **特徴量の重み付け最適化** ← コサイン以外の導入

**内容:**
- 現在は全特徴量を等しく扱っているが、「曲調」に重要な特徴を強調
- 例: Tempo, Chroma, RMSの重みを増やす（リズム・調性・エネルギー重視）
- ユーザーフィードバックに基づく重み学習

**効果:**
- **「似ている」の定義をユーザーの感覚に近づける** ← Issue の「脳みそが飽きる」問題に効く
- librosaの範囲内で実装可能（既存システムを大きく変えない）

**実装難易度**: ⭐⭐☆☆☆ (簡単)

**実装例:**
```python
def apply_feature_weights(vector, mode="balanced"):
    weights = {
        "tempo": 2.0,      # テンポを重視
        "chroma": 1.5,     # 調性も重要
        "mfcc": 1.0,       # 通常の重み
        "spectral": 0.8    # やや軽め
    }
    # 特徴量ごとに重みを適用
    weighted_vector = vector * get_weight_vector(mode, weights)
    return weighted_vector
```

#### 4. **連鎖検索のダイバーシティ向上** ← コサイン以外の導入

**内容:**
- 単純に「最も近い曲」を選ぶのではなく、上位N件からランダムに選択
- MMR (Maximal Marginal Relevance) アルゴリズムの導入
  - 類似性とダイバーシティのバランスを取る

**効果:**
- プレイリストに多様性が生まれる（単調さを防ぐ）
- **同じような曲が連続するのを防ぐ** ← Issue の「脳みそが飽きる」問題に効く
- 連鎖検索の誤差蓄積を軽減

**実装難易度**: ⭐⭐⭐☆☆ (中)

**実装例:**
```python
def select_next_song_with_diversity(candidates, visited, diversity_factor=0.2):
    # 上位5件から選択
    top_k = candidates[:5]
    
    # ダイバーシティスコア = 類似度 - diversity_factor * (既訪問曲との平均類似度)
    scores = []
    for song_id, distance in top_k:
        diversity_penalty = compute_avg_similarity(song_id, visited)
        score = distance - diversity_factor * diversity_penalty
        scores.append((song_id, score))
    
    # スコアが最小（最も良い）のものを選択
    return min(scores, key=lambda x: x[1])[0]
```

### 中期的改善（数週間〜数ヶ月）: DeepLearning の導入

#### 5. **深層学習の埋め込みモデルの導入** ← DeepLearning

**なぜDeepLearningが必要か？**
- librosaの統計量（平均値）だけでは、時系列の構造情報が失われる
- 深層学習モデルは、「曲全体の雰囲気」を学習済み
- **本質的に「似ている曲」を見つける能力が高い** ← Issue の根本解決

**推奨モデル:**

##### a) **OpenL3** (Open Source, MIT License) ← 最優先推奨

- **特徴**: 音声・画像の汎用埋め込みモデル
- **次元**: 512次元 または 6144次元
- **利点**: 
  - librosaよりも深い音響特徴を学習済み
  - 時系列構造を保持
  - Python実装が簡単 (`pip install openl3`)
  - **計算コストと精度のバランスが最良**

**期待される効果:**
- **「いきなり違う曲」問題の大幅改善** (10〜30%の精度向上見込み)
- 「関連なさそうな曲」が減少
- ユーザーが「飽きない」プレイリストが生成される

**実装難易度**: ⭐⭐⭐☆☆ (中)

```python
import openl3
import soundfile as sf

def extract_openl3_embedding(audio_path):
    audio, sr = sf.read(audio_path)
    emb, ts = openl3.get_audio_embedding(
        audio, sr, 
        content_type="music",  # 音楽用モデル
        embedding_size=512     # 512次元を推奨
    )
    return np.mean(emb, axis=0)  # 時間方向で平均
```

##### b) **CLAP (Contrastive Language-Audio Pretraining)**
- **特徴**: 音声と言語を同時に学習したマルチモーダルモデル
- **次元**: 512次元
- **利点**:
  - テキストで「明るい曲」「落ち着いた曲」のような検索が可能
  - 最新の技術（2023年以降）
  - 曲調の意味的理解が深い

**実装難易度**: ⭐⭐⭐⭐☆ (中〜高)

```python
import laion_clap

model = laion_clap.CLAP_Module(enable_fusion=False)
model.load_ckpt()  # デフォルトのcheckpointをロード

def extract_clap_embedding(audio_path):
    audio_data = model.read_audio(audio_path)
    audio_embed = model.get_audio_embedding_from_data(x=audio_data)
    return audio_embed[0]
```

##### c) **MusicNN**
- **特徴**: 音楽専用の特徴量抽出CNN
- **次元**: 200次元
- **利点**: 
  - 音楽ジャンル分類で高精度
  - 計算が軽量

**実装難易度**: ⭐⭐⭐☆☆ (中)

#### 6. **ハイブリッドアプローチ** ← DeepLearning + 既存手法

**内容:**
- librosaの特徴量と深層学習の埋め込みを組み合わせる
- 例: `[OpenL3 (512次元) + librosa特徴量 (33次元)] = 545次元`
- または、2段階フィルタリング:
  1. 深層学習で粗い検索（上位100件）
  2. librosaで精密な並び替え

**効果:**
- 両方の長所を活かせる
- 既存システムを段階的に移行できる（リスク軽減）
- **Issue の問題を段階的に改善しながら検証できる**

**実装難易度**: ⭐⭐⭐☆☆ (中)

#### 7. **ユーザーフィードバックループの構築**

**内容:**
- プレイリストに「👍 良い」「👎 イマイチ」のフィードバックボタンを追加
- フィードバックデータを使って:
  - 特徴量の重みを調整
  - 距離関数のハイパーパラメータを最適化
  - 個別ユーザーの嗜好を学習

**効果:**
- 実際のユーザー体験に基づく改善
- 継続的な精度向上が可能
- **「脳みそが飽きる」問題を直接フィードバックから改善**

**実装難易度**: ⭐⭐⭐☆☆ (中)

### 長期的改善（数ヶ月〜半年以上）: より高度なDeepLearning

#### 8. **Graph-based レコメンデーション** ← DeepLearning応用

**内容:**
- 楽曲をノード、類似度をエッジとするグラフを構築
- PageRankやNode2Vecでグローバルな関係性を学習
- 単純な距離だけでなく、ネットワーク構造を考慮

**効果:**
- 「この曲を聴く人はこの曲も聴く」のような間接的な類似性を発見
- 連鎖検索の誤差蓄積を軽減
- **「知らない曲」でも「関連がある曲」を見つけられる**

**実装難易度**: ⭐⭐⭐⭐☆ (高)

#### 9. **トランスフォーマーベースのシーケンスモデル** ← DeepLearning応用

**内容:**
- 連鎖検索全体を1つのシーケンスとして学習
- 例: Music Transformer, Jukebox
- 「この順番で聴くと良い」を学習

**効果:**
- プレイリスト全体の流れを最適化
- 急激な曲調変化を回避
- **「脳みそが飽きない」最適なプレイリスト生成**

**実装難易度**: ⭐⭐⭐⭐⭐ (非常に高)

---

## 推奨実装ロードマップ

### Phase 1: 即効性のある改善（1〜2週間） ← コサイン距離以外の導入

**優先度: 最高 ⭐⭐⭐**

1. ✅ **距離閾値の導入** → 「いきなり違う曲」を防ぐ
2. ✅ **複合距離関数の使用** → Cosine + L2 の組み合わせ
3. ✅ **特徴量の重み付け調整** → balanced モードのチューニング

**期待される効果:**
- Issue の「いきなり違う曲になる現象」が20〜40%減少
- 実装リスクが低く、すぐに効果確認可能
- 既存システムへの影響が最小限

### Phase 2: 深層学習の導入（1〜2ヶ月） ← DeepLearning

**優先度: 高 ⭐⭐☆**

4. ✅ **OpenL3の導入** → 計算コストと精度のバランスが良い
5. ✅ **ハイブリッド検索** → librosa + OpenL3の2段階検索
6. ⏸️ **A/Bテスト** → 新旧システムの比較評価

**期待される効果:**
- Issue の問題が60〜80%改善
- 本質的な精度向上（10〜30%）
- 「関連なさそうな曲」が大幅に減少

### Phase 3: 継続的改善（3ヶ月〜） ← より高度なDeepLearning

**優先度: 中 ⭐☆☆**

7. ✅ **ユーザーフィードバック機能** → 実データに基づく最適化
8. ⏸️ **CLAPの検証** → 言語クエリでの検索も可能に
9. ⏸️ **Graph-based手法の研究** → より高度なレコメンド

**期待される効果:**
- Issue の問題をほぼ完全に解決
- 継続的な精度向上のサイクル確立
- 新しい機能（言語検索など）の追加

---

## 参考文献・リソース

### ライブラリ
- **OpenL3**: https://github.com/marl/openl3
- **CLAP**: https://github.com/LAION-AI/CLAP
- **MusicNN**: https://github.com/jordipons/musicnn

### 論文
- Look, Listen and Learn (OpenL3): https://arxiv.org/abs/1705.08168
- CLAP: https://arxiv.org/abs/2211.06687
- Music Transformer: https://arxiv.org/abs/1809.04281

### 参考実装
- Spotify's Annoy (高速近似最近傍探索): https://github.com/spotify/annoy
- FAISS (Facebook AI Similarity Search): https://github.com/facebookresearch/faiss

---

## まとめ

### Issue の質問への回答

> **質問**: コサイン距離以外の導入で解決できるのか、DeepLearningまでやるかのいずれかかな

**回答**: **両方必要です。段階的に実装することを推奨します。**

### 現状の問題（Issue より）

「母数が増えたことで前からあったいきなり違う曲になる現象の違和感が強烈。関連なさそうな自分の知らない曲に飛ぶから脳みそが飽きてしまう」

→ Cosine距離だけでは、微妙な類似性の違いを捉えきれず、「いきなり違う曲」に飛ぶ現象が発生している。

### 推奨アクション（優先順）

1. **Phase 1（1〜2週間）: コサイン距離以外の導入**
   - 距離閾値、複合距離関数、重み付け最適化
   - → **即座に効果確認可能。Issue の問題を20〜40%軽減**

2. **Phase 2（1〜2ヶ月）: DeepLearning の導入**
   - OpenL3などの深層学習埋め込みモデル
   - → **本質的な精度向上（10〜30%）。Issue の問題を60〜80%改善**

3. **Phase 3（3ヶ月〜）: 継続的改善**
   - ユーザーフィードバック、より高度なモデル
   - → **Issue の問題をほぼ完全に解決**

### 期待される効果

- **「いきなり違う曲になる」現象の大幅減少**
- **「関連なさそうな知らない曲に飛ぶ」問題の改善**
- **「脳みそが飽きてしまう」状態の解消**
- 連鎖検索の精度向上（10〜30%の改善見込み）
- ユーザー体験の向上（違和感のある推薦の減少）
- プレイリストの多様性とまとまりの両立

### 最優先推奨: 距離閾値 + OpenL3

- **距離閾値**: 最も簡単で即効性がある。今すぐ実装すべき
- **OpenL3**: 実装難易度と効果のバランスが最良。Phase 2 で最優先

**結論**: Cosine距離以外の手法（短期施策）で即座に改善し、DeepLearning（OpenL3）で本質的に解決する。両方を段階的に実装することで、リスクを抑えながら最大の効果を得られる。
