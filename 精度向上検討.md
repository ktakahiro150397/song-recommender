# 楽曲レコメンド精度向上の検討

## 問題の整理

### 現状の課題

ユーザーからの報告:
- **母数が増えたことで「いきなり違う曲になる現象」が顕著に**
- 関連なさそうな知らない曲に飛んでしまう
- 脳が飽きてしまう（興味を失う）

これは、データベースの楽曲数が増加したことで、ベクトル空間の密度が変化し、局所的な類似性の精度が低下している可能性が高い。

### 現在の実装

#### 音声特徴量抽出
- **ライブラリ**: librosa
- **特徴量**: 
  - MFCC (20次元) + MFCC Delta (20次元): 音色・質感
  - Chroma (12次元): 和音・調性
  - Tonnetz (6次元): 和声的関係
  - Spectral特徴量 (7次元): Contrast, Centroid, Rolloff等
  - リズム・エネルギー (3次元): Tempo, RMS, Zero Crossing Rate
- **モード**:
  - minimal: 15次元（テンポ・明るさ重視）
  - balanced: 33次元（汎用的）
  - full: 72次元（全特徴量）

#### 類似度計算
- **距離関数**: Cosine距離
- **ベクトルDB**: ChromaDB (HNSW index)
- **検索方式**: 連鎖検索（各ステップで最も近い未訪問曲を選択）

---

## 問題の原因分析

### 1. 次元の呪い（Curse of Dimensionality）

**問題点:**
- 高次元空間（特にfullモードの72次元）では、すべての点が等距離に見える傾向
- Cosine距離だけでは、微妙な差異を捉えきれない
- 距離の分散が小さくなり、「似ている」と「似ていない」の境界が曖昧に

**影響:**
- 本来類似していない曲が「距離が近い」と判定される
- 連鎖検索で急に違うジャンルに飛んでしまう

### 2. 特徴量の均質化

**問題点:**
- librosaの統計量（平均値）だけでは、時系列の構造情報が失われる
- 異なる曲でも、平均化すると似たベクトルになってしまう可能性
- 特にChroma（調性）の重みが、実際の「曲調の似た感じ」と一致しない場合がある

**影響:**
- 調性は同じだが、リズムや雰囲気が全く異なる曲が類似と判定される
- 「曲調」ではなく「音響特性」の類似になっている

### 3. 連鎖検索の蓄積誤差

**問題点:**
- 連鎖検索では、各ステップでの微小な誤差が蓄積
- 最初は似ていても、10曲、20曲と進むうちに元の曲とかけ離れる
- 距離の閾値がないため、「どれだけ似ていないか」の判断ができない

**影響:**
- プレイリストの後半が元の曲と無関係になる
- ユーザーが違和感を感じる

### 4. データセットの偏り

**問題点:**
- 特定のジャンルや音源（例: アイドルマス系楽曲）が大量にある場合、ベクトル空間がそちらに偏る
- レアなジャンルの楽曲は孤立し、不適切な類似曲と結びつく可能性

---

## 解決策の提案

### 短期的改善（すぐ実装可能）

#### 1. **距離閾値の導入**

**内容:**
- 連鎖検索時に「最大距離」を設定
- 例: `distance > 0.01` の場合は連鎖を打ち切る、または警告を出す
- ユーザーに「ここから先は類似度が低下します」と通知

**メリット:**
- 急激な曲調変化を防ぐ
- 実装が簡単（数行の変更）

**実装例:**
```python
MAX_DISTANCE_THRESHOLD = 0.01  # 調整可能

if best_distance > MAX_DISTANCE_THRESHOLD:
    print(f"⚠️ 類似度が低下しています（距離: {best_distance:.6f}）")
    # オプション: 検索を打ち切る or 続ける
```

#### 2. **複合距離関数の使用**

**内容:**
- Cosine距離だけでなく、L2距離や内積も併用
- 複数の距離を組み合わせたスコアを計算
  - 例: `score = 0.7 * cosine + 0.3 * l2_normalized`

**メリット:**
- 異なる視点での類似性を考慮できる
- ベクトルの「向き」と「大きさ」の両方を評価

**実装例:**
```python
def combined_distance(vec1, vec2):
    cosine_dist = cosine_distance(vec1, vec2)
    l2_dist = np.linalg.norm(vec1 - vec2)
    l2_normalized = l2_dist / np.sqrt(len(vec1))  # 次元数で正規化
    return 0.7 * cosine_dist + 0.3 * l2_normalized
```

#### 3. **特徴量の重み付け最適化**

**内容:**
- 現在は全特徴量を等しく扱っているが、「曲調」に重要な特徴を強調
- 例: Tempo, Chroma, RMSの重みを増やす
- ユーザーフィードバックに基づく重み学習

**メリット:**
- 「似ている」の定義をユーザーの感覚に近づける
- librosaの範囲内で実装可能

**実装例:**
```python
def apply_feature_weights(vector, mode="balanced"):
    weights = {
        "tempo": 2.0,      # テンポを重視
        "chroma": 1.5,     # 調性も重要
        "mfcc": 1.0,       # 通常の重み
        "spectral": 0.8    # やや軽め
    }
    # 特徴量ごとに重みを適用
    weighted_vector = vector * get_weight_vector(mode, weights)
    return weighted_vector
```

#### 4. **連鎖検索のダイバーシティ向上**

**内容:**
- 単純に「最も近い曲」を選ぶのではなく、上位N件からランダムに選択
- MMR (Maximal Marginal Relevance) アルゴリズムの導入
  - 類似性とダイバーシティのバランスを取る

**メリット:**
- プレイリストに多様性が生まれる
- 同じような曲が連続するのを防ぐ

**実装例:**
```python
def select_next_song_with_diversity(candidates, visited, diversity_factor=0.2):
    # 上位5件から選択
    top_k = candidates[:5]
    
    # ダイバーシティスコア = 類似度 - diversity_factor * (既訪問曲との平均類似度)
    scores = []
    for song_id, distance in top_k:
        diversity_penalty = compute_avg_similarity(song_id, visited)
        score = distance - diversity_factor * diversity_penalty
        scores.append((song_id, score))
    
    # スコアが最小（最も良い）のものを選択
    return min(scores, key=lambda x: x[1])[0]
```

### 中期的改善（数週間〜数ヶ月）

#### 5. **深層学習の埋め込みモデルの導入**

**推奨モデル:**

##### a) **OpenL3** (Open Source, MIT License)
- **特徴**: 音声・画像の汎用埋め込みモデル
- **次元**: 512次元 または 6144次元
- **利点**: 
  - librosaよりも深い音響特徴を学習済み
  - 時系列構造を保持
  - Python実装が簡単 (`pip install openl3`)

**実装難易度**: ⭐⭐☆☆☆ (中)

```python
import openl3
import soundfile as sf

def extract_openl3_embedding(audio_path):
    audio, sr = sf.read(audio_path)
    emb, ts = openl3.get_audio_embedding(
        audio, sr, 
        content_type="music",  # 音楽用モデル
        embedding_size=512     # 512次元を推奨
    )
    return np.mean(emb, axis=0)  # 時間方向で平均
```

##### b) **CLAP (Contrastive Language-Audio Pretraining)**
- **特徴**: 音声と言語を同時に学習したマルチモーダルモデル
- **次元**: 512次元
- **利点**:
  - テキストで「明るい曲」「落ち着いた曲」のような検索が可能
  - 最新の技術（2023年以降）
  - 曲調の意味的理解が深い

**実装難易度**: ⭐⭐⭐☆☆ (中〜高)

```python
import laion_clap

model = laion_clap.CLAP_Module(enable_fusion=False)
model.load_ckpt()  # デフォルトのcheckpointをロード

def extract_clap_embedding(audio_path):
    audio_data = model.read_audio(audio_path)
    audio_embed = model.get_audio_embedding_from_data(x=audio_data)
    return audio_embed[0]
```

##### c) **MusicNN**
- **特徴**: 音楽専用の特徴量抽出CNN
- **次元**: 200次元
- **利点**: 
  - 音楽ジャンル分類で高精度
  - 計算が軽量

**実装難易度**: ⭐⭐☆☆☆ (中)

#### 6. **ハイブリッドアプローチ**

**内容:**
- librosaの特徴量と深層学習の埋め込みを組み合わせる
- 例: `[OpenL3 (512次元) + librosa特徴量 (33次元)] = 545次元`
- または、2段階フィルタリング:
  1. 深層学習で粗い検索（上位100件）
  2. librosaで精密な並び替え

**メリット:**
- 両方の長所を活かせる
- 既存システムを段階的に移行できる

#### 7. **ユーザーフィードバックループの構築**

**内容:**
- プレイリストに「👍 良い」「👎 イマイチ」のフィードバックボタンを追加
- フィードバックデータを使って:
  - 特徴量の重みを調整
  - 距離関数のハイパーパラメータを最適化
  - 個別ユーザーの嗜好を学習

**メリット:**
- 実際のユーザー体験に基づく改善
- 継続的な精度向上が可能

### 長期的改善（数ヶ月〜半年以上）

#### 8. **Graph-based レコメンデーション**

**内容:**
- 楽曲をノード、類似度をエッジとするグラフを構築
- PageRankやNode2Vecでグローバルな関係性を学習
- 単純な距離だけでなく、ネットワーク構造を考慮

**メリット:**
- 「この曲を聴く人はこの曲も聴く」のような間接的な類似性を発見
- 連鎖検索の誤差蓄積を軽減

#### 9. **トランスフォーマーベースのシーケンスモデル**

**内容:**
- 連鎖検索全体を1つのシーケンスとして学習
- 例: Music Transformer, Jukebox
- 「この順番で聴くと良い」を学習

**メリット:**
- プレイリスト全体の流れを最適化
- 急激な曲調変化を回避

---

## 推奨実装ロードマップ

### Phase 1: 即効性のある改善（1〜2週間）
1. ✅ **距離閾値の導入** → 連鎖検索の暴走を防ぐ
2. ✅ **特徴量の重み付け調整** → balanced モードのチューニング
3. ✅ **ダイバーシティの向上** → MMRアルゴリズム導入

### Phase 2: 深層学習の導入（1〜2ヶ月）
4. ✅ **OpenL3の導入** → 計算コストと精度のバランスが良い
5. ✅ **ハイブリッド検索** → librosa + OpenL3の2段階検索
6. ⏸️ **A/Bテスト** → 新旧システムの比較評価

### Phase 3: 継続的改善（3ヶ月〜）
7. ✅ **ユーザーフィードバック機能** → 実データに基づく最適化
8. ⏸️ **CLAPの検証** → 言語クエリでの検索も可能に
9. ⏸️ **Graph-based手法の研究** → より高度なレコメンド

---

## 参考文献・リソース

### ライブラリ
- **OpenL3**: https://github.com/marl/openl3
- **CLAP**: https://github.com/LAION-AI/CLAP
- **MusicNN**: https://github.com/jordipons/musicnn

### 論文
- Look, Listen and Learn (OpenL3): https://arxiv.org/abs/1705.08168
- CLAP: https://arxiv.org/abs/2211.06687
- Music Transformer: https://arxiv.org/abs/1809.04281

### 参考実装
- Spotify's Annoy (高速近似最近傍探索): https://github.com/spotify/annoy
- FAISS (Facebook AI Similarity Search): https://github.com/facebookresearch/faiss

---

## まとめ

### 現状の問題
母数増加により、Cosine距離だけでは微妙な類似性の違いを捉えきれず、「いきなり違う曲」に飛ぶ現象が発生。

### 推奨アクション
1. **すぐできる対策**: 距離閾値、特徴量の重み付け、ダイバーシティ向上
2. **本質的解決**: OpenL3などの深層学習埋め込みの導入
3. **継続的改善**: ユーザーフィードバックに基づく最適化

### 期待される効果
- 連鎖検索の精度向上（10〜30%の改善が見込める）
- ユーザー体験の向上（違和感のある推薦の減少）
- プレイリストの多様性とまとまりの両立

**結論**: Cosine距離以外の手法（深層学習モデル）と、距離閾値などの工夫を組み合わせることで、大幅な精度向上が期待できる。OpenL3の導入を最優先に推奨。
